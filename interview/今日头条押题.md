#往届面试题

[2016.01.27](http://www.jianshu.com/p/8ee1bcc0f15e)

[2015-09-09](http://www.100mian.com/mianshi/android/4211.html)

[2016-03-31](http://blog.csdn.net/theone10211024/article/details/51025022)

[2015-09-09](http://www.cnblogs.com/baokang/p/4828397.html)

[2016-3-30](http://tvbingo.cn/forum.php?mod=viewthread&tid=494)

[牛客网](http://www.nowcoder.com/)

#怎么从100w个数中，找出100个最大数？

step1：取前m个元素（例如m=100），建立一个小顶堆。保持一个小顶堆的性质的步骤，运行时间为O（lgm);建立一个小顶堆运行时间为m*O（lgm）=O(m lgm);       
step2:顺序读取后续元素，直到结束。每次读取一个元素，如果该元素比堆顶元素小，直接丢弃 
如果大于堆顶元素，则用该元素替换堆顶元素，然后保持最小堆性质。最坏情况是每次都需要替换掉堆顶的最小元素，因此需要维护堆的代价为(N-m)*O(lgm); 
最后这个堆中的元素就是前最大的10W个。时间复杂度为O(N lgm）。 

#写一个二分算法

    public int binarySearch(int num){  
            System.out.println("****************使用二分法查找****************");  
            long startTime = System.currentTimeMillis();  
            Arrays.sort(array);  
            int index = 0; // 检索的时候  
            int start = 0;  //用start和end两个索引控制它的查询范围  
            int end = array.length - 1;  
            count = 0;  
            for (int i = 0; i < array.length; i++){   
                count++;  
                index = (start + end) / 2;  
                if(array.length - 1 == i){  
                    System.out.println("抱歉，没有找到");  
                }else if (array[index] < num){  
                    start = index;  
                }else if (array[index] > num){  
                    end = index;  
                }else{  
                    System.out.println(array[index] + "找到了，在数组下标为" + index + "的地方,查找了" + count + "次。");  
                    break;  
                }  
            }  
            long endTime = System.currentTimeMillis();  
            System.out.println("此次查询共花费" + (endTime - startTime) + "毫秒的时间。");  
            return count;  
        }  


